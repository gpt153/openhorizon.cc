# Feature: Working/Formal Mode Toggle for Content Display

The following plan should be complete, but it's important that you validate documentation and codebase patterns and task sanity before you start implementing.

Pay special attention to naming of existing utils types and models. Import from the right files etc.

## Feature Description

Add a global toggle that switches all descriptive text fields between "Working Mode" (authentic, informal descriptions of what actually happens) and "Formal Mode" (polished, Erasmus+-compliant language suitable for applications and reports).

This feature enables users to:
- Maintain authentic working descriptions for internal planning
- Auto-generate or manually create formal versions for EU submissions
- Toggle between views with a single click in the header
- See exactly what will appear in official documents
- Bridge the gap between practice and bureaucratic requirements

## User Story

As a project coordinator
I want to toggle between working and formal descriptions of activities
So that I can plan authentically while having application-ready language available

**Acceptance Criteria:**
- ✅ Toggle visible in header at all times
- ✅ Affects 11 fields across projects and programmes
- ✅ Working mode by default (authentic planning)
- ✅ Formal mode auto-generated by AI or editable manually
- ✅ Selection persists across browser sessions
- ✅ Graceful fallback if formal version missing
- ✅ Clear visual indicators of current mode

## Problem Statement

Erasmus+ applications require formal, bureaucratic language that doesn't reflect the authentic reality of youth work. A simple activity like "we played a board game" must become "facilitated intercultural dialogue through structured game-based learning activities." This creates friction:

1. **Planning Disconnect**: Coordinators think in practical terms but write in formal terms
2. **Translation Burden**: Manual conversion is time-consuming and error-prone
3. **Version Confusion**: No clear source of truth for what's real vs what's written
4. **Approval Optimization**: Language must be optimized for EU evaluation criteria

## Solution Statement

Implement dual storage for all descriptive text fields: one version captures authentic working descriptions, another stores formal application-ready language. A global UI toggle switches between presentation modes. AI-powered formalization generates formal versions automatically, while manual editing remains possible.

## Feature Metadata

**Feature Type**: Enhancement
**Estimated Complexity**: High
**Primary Systems Affected**: Database Schema, AI Generation, State Management, Frontend Display
**Dependencies**: None (uses existing LangChain setup)
**Implementation Time**: 3-5 days

---

## CONTEXT REFERENCES

### Relevant Codebase Files - IMPORTANT: YOU MUST READ THESE FILES BEFORE IMPLEMENTING!

- `/app/prisma/schema.prisma` (lines 72-110, 159-181, 189-247) - Why: Database models for Project, Programme, ProgrammeDay, ProgrammeSession
- `/app/src/lib/ai/chains/programme-generation.ts` (full file) - Why: AI chain pattern for LLM initialization and prompt structure
- `/app/src/lib/ai/chains/project-concept-generation.ts` (full file) - Why: Project generation pattern to mirror
- `/app/src/lib/ai/programme-prompts.ts` (full file) - Why: Prompt templates and type definitions to update
- `/app/src/server/routers/projects.ts` (lines 59-90) - Why: Update mutation pattern with multi-tenant authorization
- `/app/src/server/routers/programmes.ts` (lines 148-194) - Why: Session update mutation pattern
- `/app/src/components/layout/Header.tsx` (full file) - Why: Current header structure for toggle integration
- `/app/src/app/(dashboard)/projects/[id]/page.tsx` (lines 293-435) - Why: Field display patterns for 5 affected project fields
- `/app/src/app/(dashboard)/projects/[id]/programme/page.tsx` (lines 179-330) - Why: Programme display patterns for sessions and days

### New Files to Create

- `/app/src/lib/stores/contentModeStore.ts` - Zustand store for working/formal mode toggle with localStorage persistence
- `/app/src/lib/hooks/useContentField.ts` - React hook for field display logic (returns correct version based on mode)
- `/app/src/lib/ai/chains/content-formalization.ts` - AI chain for formalizing working mode text to Erasmus+ language
- `/app/src/components/layout/ContentModeToggle.tsx` - Toggle button component for header
- `/app/src/components/ui/ContentModeBadge.tsx` - Mode indicator badge component
- `/app/prisma/migrations/YYYYMMDDHHMMSS_add_formal_fields/migration.sql` - Database migration adding formal columns

### Relevant Documentation - YOU SHOULD READ THESE BEFORE IMPLEMENTING!

- [Zustand Persist Middleware](https://docs.pmnd.rs/zustand/integrations/persisting-store-state)
  - Specific section: "Usage with TypeScript" and "Partialize"
  - Why: First Zustand store in codebase, must handle SSR properly

- [LangChain Chat Models](https://js.langchain.com/docs/modules/model_io/models/chat/)
  - Specific section: ChatOpenAI initialization and invoke patterns
  - Why: Creating new formalization chain following existing patterns

- [Prisma Schema - Field Attributes](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#attributes)
  - Specific section: @map attribute for column naming
  - Why: All new fields must follow snake_case → camelCase pattern

- [React Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components)
  - Specific section: "use client" directive
  - Why: Zustand store requires client-side rendering

### Patterns to Follow

**Naming Conventions:**
```typescript
// File names: kebab-case
content-mode-store.ts
working-formal-toggle.md

// Component files: PascalCase
ContentModeToggle.tsx
ContentModeBadge.tsx

// Variables: camelCase
contentMode, isFormalMode, workingValue

// Database columns: snake_case with @map
targetGroupDescriptionFormal → target_group_description_formal
```

**Zustand Store Pattern (NEW - First Store in Codebase):**
```typescript
// Pattern for client-side global state with persistence
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

export type ContentMode = 'working' | 'formal'

interface ContentModeStore {
  mode: ContentMode
  setMode: (mode: ContentMode) => void
  toggleMode: () => void
}

export const useContentModeStore = create<ContentModeStore>()(
  persist(
    (set, get) => ({
      mode: 'working',
      setMode: (mode) => set({ mode }),
      toggleMode: () => set({ mode: get().mode === 'working' ? 'formal' : 'working' }),
    }),
    {
      name: 'content-mode-storage',
      partialize: (state) => ({ mode: state.mode }),
    }
  )
)
```

**Database Migration Pattern:**
```sql
-- Add nullable TEXT columns for formal versions
ALTER TABLE projects
  ADD COLUMN target_group_description_formal TEXT,
  ADD COLUMN inclusion_plan_overview_formal TEXT,
  -- ...etc
;

-- Add comments for documentation
COMMENT ON COLUMN projects.target_group_description_formal
  IS 'Formal/application-ready version of target group description';
```

**AI Formalization Chain Pattern:**
```typescript
// Pattern from programme-generation.ts lines 15-18, 50-80
const llm = new ChatOpenAI({
  modelName: 'gpt-4-turbo-preview',
  temperature: 0.3, // Lower for consistency
  openAIApiKey: process.env.OPENAI_API_KEY,
})

const response = await llm.invoke([{
  role: 'user',
  content: prompt,
}])

// Handle JSON extraction with markdown code blocks
let jsonText = response.content.toString()
if (jsonText.includes('```json')) {
  const match = jsonText.match(/```json\n([\s\S]*?)\n```/)
  if (match) jsonText = match[1]
}

try {
  return JSON.parse(jsonText)
} catch (error) {
  console.error('Failed to parse AI response:', jsonText)
  throw new Error('Failed to parse AI formalization response')
}
```

**Field Display Hook Pattern:**
```typescript
// Pattern for displaying correct field version
export function useContentField(
  workingValue: string | null | undefined,
  formalValue: string | null | undefined
): string {
  const { mode } = useContentModeStore()

  if (mode === 'formal' && formalValue) {
    return formalValue
  }
  return workingValue || ''
}
```

---

## IMPLEMENTATION PLAN

### Phase 1: Database Schema & Migration

**Goal**: Add formal field columns to database for dual storage

**Tasks:**
1. Update Prisma schema with formal field definitions
2. Generate and test migration
3. Verify backward compatibility

**Duration**: 2-3 hours

---

### Phase 2: State Management

**Goal**: Create global Zustand store for content mode toggle

**Tasks:**
1. Create contentModeStore with persist middleware
2. Create useContentField display hook
3. Test localStorage persistence and SSR handling

**Duration**: 1-2 hours

---

### Phase 3: AI Formalization Chain

**Goal**: Build AI chain for working → formal translation

**Tasks:**
1. Create content-formalization.ts chain
2. Define context-specific prompts for different field types
3. Update project/programme generation to produce both modes
4. Test formalization quality

**Duration**: 4-6 hours

---

### Phase 4: Backend Integration

**Goal**: Add tRPC mutations for formalization and update existing mutations

**Tasks:**
1. Add formalize mutations to projects and programmes routers
2. Update input schemas to accept formal fields
3. Update Inngest functions to save both modes
4. Test multi-tenant authorization

**Duration**: 3-4 hours

---

### Phase 5: Frontend Integration

**Goal**: Add toggle UI and update all affected pages

**Tasks:**
1. Create ContentModeToggle component for header
2. Create ContentModeBadge indicator component
3. Update project detail page (5 fields)
4. Update programme page (6 fields)
5. Add formalize buttons for on-demand translation

**Duration**: 4-6 hours

---

### Phase 6: Testing & Polish

**Goal**: Comprehensive testing and edge case handling

**Tasks:**
1. Test toggle functionality across pages
2. Test with missing formal versions (fallback)
3. Test formalization for all field types
4. Test persistence across sessions
5. Performance testing

**Duration**: 2-3 hours

---

## STEP-BY-STEP TASKS

IMPORTANT: Execute every task in order, top to bottom. Each task is atomic and independently testable.

### Phase 1: Database Schema

#### UPDATE /app/prisma/schema.prisma

- **IMPLEMENT**: Add formal field equivalents to Project, ProgrammeDay, ProgrammeSession models
- **PATTERN**: Mirror existing field definitions (lines 72-110, 189-247)
- **IMPORTS**: None (schema file)
- **GOTCHA**: All formal fields must be nullable (optional)
- **VALIDATE**: `npx prisma validate`

**Changes:**

```prisma
// In Project model (after line 92):
  // Formal mode equivalents
  targetGroupDescriptionFormal  String?  @map("target_group_description_formal") @db.Text
  inclusionPlanOverviewFormal   String?  @map("inclusion_plan_overview_formal") @db.Text
  partnerProfileFormal          String?  @map("partner_profile_formal") @db.Text
  sustainabilityNarrativeFormal String?  @map("sustainability_narrative_formal") @db.Text
  impactNarrativeFormal         String?  @map("impact_narrative_formal") @db.Text

// In ProgrammeDay model (after line 199):
  // Formal mode equivalents
  morningFocusFormal    String?  @map("morning_focus_formal") @db.VarChar(500)
  afternoonFocusFormal  String?  @map("afternoon_focus_formal") @db.VarChar(500)
  eveningFocusFormal    String?  @map("evening_focus_formal") @db.VarChar(500)

// In ProgrammeSession model (after line 221):
  // Formal mode equivalents
  titleFormal             String?  @map("title_formal") @db.VarChar(200)
  descriptionFormal       String?  @map("description_formal") @db.Text
  preparationNotesFormal  String?  @map("preparation_notes_formal") @db.Text
```

---

#### CREATE /app/prisma/migrations/YYYYMMDDHHMMSS_add_formal_fields/migration.sql

- **IMPLEMENT**: SQL migration adding 11 formal columns
- **PATTERN**: Follow existing migration pattern from programme_migration.sql
- **IMPORTS**: None (SQL file)
- **GOTCHA**: Must use exact snake_case names with proper types
- **VALIDATE**: `npx prisma migrate dev --name add_formal_fields`

**Content:**

```sql
-- Add formal mode fields to projects table
ALTER TABLE projects
  ADD COLUMN target_group_description_formal TEXT,
  ADD COLUMN inclusion_plan_overview_formal TEXT,
  ADD COLUMN partner_profile_formal TEXT,
  ADD COLUMN sustainability_narrative_formal TEXT,
  ADD COLUMN impact_narrative_formal TEXT;

-- Add formal mode fields to programme_days table
ALTER TABLE programme_days
  ADD COLUMN morning_focus_formal VARCHAR(500),
  ADD COLUMN afternoon_focus_formal VARCHAR(500),
  ADD COLUMN evening_focus_formal VARCHAR(500);

-- Add formal mode fields to programme_sessions table
ALTER TABLE programme_sessions
  ADD COLUMN title_formal VARCHAR(200),
  ADD COLUMN description_formal TEXT,
  ADD COLUMN preparation_notes_formal TEXT;

-- Add documentation comments
COMMENT ON COLUMN projects.target_group_description_formal IS 'Formal/application-ready version of target group description';
COMMENT ON COLUMN programme_sessions.title_formal IS 'Formal/application-ready version of session title';
COMMENT ON COLUMN programme_days.morning_focus_formal IS 'Formal/application-ready version of morning focus';
```

**Run migration:**
```bash
cd /worktrees/openhorizon.cc/issue-1/app
npx prisma migrate dev --name add_formal_fields
npx prisma generate
```

---

### Phase 2: State Management

#### CREATE /app/src/lib/stores/contentModeStore.ts

- **IMPLEMENT**: Zustand store with persist middleware for content mode toggle
- **PATTERN**: First Zustand store in codebase - set the standard
- **IMPORTS**:
  ```typescript
  import { create } from 'zustand'
  import { persist } from 'zustand/middleware'
  ```
- **GOTCHA**: Must handle SSR - store only works client-side
- **VALIDATE**: Import in a test component and verify mode toggles

**Implementation:**

```typescript
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

export type ContentMode = 'working' | 'formal'

interface ContentModeState {
  mode: ContentMode
  setMode: (mode: ContentMode) => void
  toggleMode: () => void
  isWorking: boolean
  isFormal: boolean
}

export const useContentModeStore = create<ContentModeState>()(
  persist(
    (set, get) => ({
      mode: 'working', // Default to working mode

      setMode: (mode: ContentMode) => set({ mode }),

      toggleMode: () => {
        const currentMode = get().mode
        set({ mode: currentMode === 'working' ? 'formal' : 'working' })
      },

      // Computed getters for convenience
      get isWorking() {
        return get().mode === 'working'
      },

      get isFormal() {
        return get().mode === 'formal'
      },
    }),
    {
      name: 'content-mode-storage',
      partialize: (state) => ({ mode: state.mode }),
    }
  )
)
```

---

#### CREATE /app/src/lib/hooks/useContentField.ts

- **IMPLEMENT**: React hook for field display logic based on current mode
- **PATTERN**: Custom hook for display logic abstraction
- **IMPORTS**:
  ```typescript
  import { useContentModeStore } from '@/lib/stores/contentModeStore'
  ```
- **GOTCHA**: Must handle null/undefined values gracefully
- **VALIDATE**: Test with various field value combinations

**Implementation:**

```typescript
import { useContentModeStore } from '@/lib/stores/contentModeStore'

/**
 * Hook to get the appropriate field value based on current content mode
 * Falls back to working mode if formal version is not available
 */
export function useContentField(
  workingValue: string | null | undefined,
  formalValue: string | null | undefined
): string {
  const { mode } = useContentModeStore()

  if (mode === 'formal' && formalValue) {
    return formalValue
  }

  return workingValue || ''
}

/**
 * Check if a formal version exists for a field
 */
export function hasFormalVersion(
  formalValue: string | null | undefined
): boolean {
  return Boolean(formalValue && formalValue.trim().length > 0)
}

/**
 * Get field name for tRPC updates based on current mode
 */
export function getFieldName(
  baseFieldName: string,
  mode: 'working' | 'formal'
): string {
  return mode === 'formal' ? `${baseFieldName}Formal` : baseFieldName
}
```

---

### Phase 3: AI Formalization Chain

#### CREATE /app/src/lib/ai/chains/content-formalization.ts

- **IMPLEMENT**: AI chain for formalizing working mode text to Erasmus+ language
- **PATTERN**: Mirror programme-generation.ts structure (lines 15-18, 50-80)
- **IMPORTS**:
  ```typescript
  import { ChatOpenAI } from '@langchain/openai'
  import { PromptTemplate } from '@langchain/core/prompts'
  ```
- **GOTCHA**: Different prompts needed for different field contexts
- **VALIDATE**: Test with sample working text, verify formal output quality

**Implementation:**

```typescript
import { ChatOpenAI } from '@langchain/openai'
import { PromptTemplate } from '@langchain/core/prompts'

type FieldContext =
  | 'target_group'
  | 'inclusion_plan'
  | 'partner_profile'
  | 'sustainability'
  | 'impact'
  | 'session_title'
  | 'session_description'
  | 'session_preparation'
  | 'day_focus'

const CONTEXT_INSTRUCTIONS: Record<FieldContext, string> = {
  target_group: 'Transform into professional Erasmus+ target group description using formal EU terminology. Emphasize participant demographics, inclusion criteria, and expected outcomes.',
  inclusion_plan: 'Convert to formal inclusion and accessibility plan using Erasmus+ quality standards. Reference EU frameworks for inclusive education.',
  partner_profile: 'Formalize partner description using institutional language suitable for EU funding applications. Emphasize organizational capacity and expertise.',
  sustainability: 'Enhance with formal environmental sustainability terminology for EU applications. Reference sustainable development goals.',
  impact: 'Formalize impact narrative using EU programme evaluation language. Quantify outcomes and align with Key Action objectives.',
  session_title: 'Create professional session title suitable for official programme schedules. Use educational terminology.',
  session_description: 'Transform into formal session description for Erasmus+ documentation. Use structured learning terminology.',
  session_preparation: 'Formalize facilitator preparation notes using professional youth work terminology.',
  day_focus: 'Convert to formal daily focus description for programme documentation. Use pedagogical language.',
}

/**
 * Formalize working mode text to Erasmus+ application-ready language
 */
export async function formalizeText(
  workingText: string,
  context: FieldContext
): Promise<string> {
  const llm = new ChatOpenAI({
    modelName: 'gpt-4-turbo-preview',
    temperature: 0.3, // Lower for consistency
    openAIApiKey: process.env.OPENAI_API_KEY,
  })

  const prompt = PromptTemplate.fromTemplate(`You are an Erasmus+ application writing expert. Your task is to convert informal "working mode" text into formal, professional "application-ready" language.

CONTEXT: {contextInstruction}

WORKING MODE TEXT:
{workingText}

REQUIREMENTS:
1. Maintain all factual content and meaning
2. Use formal, professional tone appropriate for EU funding applications
3. Incorporate Erasmus+ terminology and framework language (Key Actions, learning outcomes, intercultural dialogue, etc.)
4. Ensure clarity and precision
5. Keep similar length (±20% of original)
6. Reference EU quality standards where applicable
7. Ensure compliance with Erasmus+ Programme Guide terminology

OUTPUT:
Return ONLY the formalized text, no explanations or meta-commentary.`)

  const response = await llm.invoke([
    {
      role: 'user',
      content: await prompt.format({
        contextInstruction: CONTEXT_INSTRUCTIONS[context],
        workingText,
      }),
    },
  ])

  return response.content.toString().trim()
}

/**
 * Batch formalize multiple fields for a project
 */
export async function formalizeProjectFields(fields: {
  targetGroupDescription?: string
  inclusionPlanOverview?: string
  partnerProfile?: string
  sustainabilityNarrative?: string
  impactNarrative?: string
}): Promise<{
  targetGroupDescriptionFormal?: string
  inclusionPlanOverviewFormal?: string
  partnerProfileFormal?: string
  sustainabilityNarrativeFormal?: string
  impactNarrativeFormal?: string
}> {
  const formalized: any = {}

  if (fields.targetGroupDescription) {
    formalized.targetGroupDescriptionFormal = await formalizeText(
      fields.targetGroupDescription,
      'target_group'
    )
  }

  if (fields.inclusionPlanOverview) {
    formalized.inclusionPlanOverviewFormal = await formalizeText(
      fields.inclusionPlanOverview,
      'inclusion_plan'
    )
  }

  if (fields.partnerProfile) {
    formalized.partnerProfileFormal = await formalizeText(
      fields.partnerProfile,
      'partner_profile'
    )
  }

  if (fields.sustainabilityNarrative) {
    formalized.sustainabilityNarrativeFormal = await formalizeText(
      fields.sustainabilityNarrative,
      'sustainability'
    )
  }

  if (fields.impactNarrative) {
    formalized.impactNarrativeFormal = await formalizeText(
      fields.impactNarrative,
      'impact'
    )
  }

  return formalized
}
```

---

#### UPDATE /app/src/lib/ai/prompts/project-concept-generation.ts

- **IMPLEMENT**: Update prompts to generate both working and formal versions
- **PATTERN**: Extend existing prompt template structure
- **IMPORTS**: None (updating existing file)
- **GOTCHA**: Must update output schema to include formal fields
- **VALIDATE**: Test project generation, verify both versions present

**Changes to prompt template (around lines 70-161):**

Add to each content generation section:

```typescript
// Example for Target Group Description section:
**Target Group Description** (150-200 words):
Generate TWO versions:

WORKING MODE:
- Natural, conversational tone
- Practical, easy-to-understand language
- Who they are: demographics, background, characteristics
- How they'll be recruited and involved

FORMAL MODE:
- Same content in professional Erasmus+ terminology
- Use phrases like "target cohort", "participant profile", "inclusion criteria"
- Reference Key Action 1 objectives and quality standards
- Application-ready language suitable for EU evaluators

Return format:
{
  "targetGroupDescription": "working mode version...",
  "targetGroupDescriptionFormal": "formal mode version..."
}
```

---

#### UPDATE /app/src/lib/schemas/project-concept.ts

- **IMPLEMENT**: Add formal field types to ProjectConcept schema
- **PATTERN**: Mirror existing field definitions
- **IMPORTS**: None (updating existing types)
- **GOTCHA**: All formal fields are strings (not null/undefined)
- **VALIDATE**: TypeScript compilation succeeds

**Add to schema:**

```typescript
export const ProjectConceptSchema = z.object({
  // ... existing fields

  // Working mode fields
  targetGroupDescription: z.string(),
  inclusionPlanOverview: z.string(),
  partnerProfile: z.string(),
  sustainabilityNarrative: z.string(),
  impactNarrative: z.string(),

  // NEW: Formal mode fields
  targetGroupDescriptionFormal: z.string(),
  inclusionPlanOverviewFormal: z.string(),
  partnerProfileFormal: z.string(),
  sustainabilityNarrativeFormal: z.string(),
  impactNarrativeFormal: z.string(),

  // ... rest of schema
})
```

---

#### UPDATE /app/src/lib/ai/programme-prompts.ts

- **IMPLEMENT**: Update daily structure and session prompts for dual output
- **PATTERN**: Extend existing prompt templates (lines 31-172)
- **IMPORTS**: None (updating existing)
- **GOTCHA**: Type definitions must include formal fields
- **VALIDATE**: Programme generation produces both versions

**Update DailyStructureOutput type:**

```typescript
export interface DailyStructureOutput {
  day_number: number
  theme: string
  morning_focus: string
  afternoon_focus: string
  evening_focus: string
  // NEW: Formal versions
  morning_focus_formal: string
  afternoon_focus_formal: string
  evening_focus_formal: string
  key_learning_outcomes: string[]
}
```

**Update SessionOutput type:**

```typescript
export interface SessionOutput {
  title: string
  title_formal: string // NEW
  description: string
  description_formal: string // NEW
  // ... existing fields
  preparation_notes: string
  preparation_notes_formal: string // NEW
}
```

**Update prompts to request both versions in output format.**

---

### Phase 4: Backend Integration

#### UPDATE /app/src/server/routers/projects.ts

- **IMPLEMENT**: Add formalize mutation and update schemas
- **PATTERN**: Mirror updateProject mutation (lines 59-90)
- **IMPORTS**:
  ```typescript
  import { formalizeProjectFields } from '@/lib/ai/chains/content-formalization'
  ```
- **GOTCHA**: Must verify multi-tenant authorization before formalizing
- **VALIDATE**: Test mutation with valid project ID

**Add mutation after updateProject:**

```typescript
// Formalize project content
formalizeProject: orgProcedure
  .input(z.object({ id: z.string().uuid() }))
  .mutation(async ({ ctx, input }) => {
    // Fetch project with authorization check
    const project = await ctx.prisma.project.findFirst({
      where: {
        id: input.id,
        tenantId: ctx.orgId,
      },
    })

    if (!project) {
      throw new Error('Project not found or unauthorized')
    }

    // Formalize all working mode fields
    const formalized = await formalizeProjectFields({
      targetGroupDescription: project.targetGroupDescription || undefined,
      inclusionPlanOverview: project.inclusionPlanOverview || undefined,
      partnerProfile: project.partnerProfile || undefined,
      sustainabilityNarrative: project.sustainabilityNarrative || undefined,
      impactNarrative: project.impactNarrative || undefined,
    })

    // Update project with formal versions
    await ctx.prisma.project.update({
      where: { id: input.id },
      data: formalized,
    })

    return { success: true, fieldsFormalized: Object.keys(formalized).length }
  }),
```

**Update updateProject input schema to accept formal fields:**

```typescript
data: z.object({
  // ... existing fields

  // Formal mode fields
  targetGroupDescriptionFormal: z.string().optional(),
  inclusionPlanOverviewFormal: z.string().optional(),
  partnerProfileFormal: z.string().optional(),
  sustainabilityNarrativeFormal: z.string().optional(),
  impactNarrativeFormal: z.string().optional(),
}),
```

---

#### UPDATE /app/src/server/routers/programmes.ts

- **IMPLEMENT**: Add updateDay mutation and update session schema
- **PATTERN**: Mirror updateSession mutation (lines 148-194)
- **IMPORTS**:
  ```typescript
  import { formalizeText } from '@/lib/ai/chains/content-formalization'
  ```
- **GOTCHA**: Nested authorization through programme.tenantId
- **VALIDATE**: Test updating day focus fields

**Add updateDay mutation:**

```typescript
// Update programme day fields
updateDay: orgProcedure
  .input(
    z.object({
      dayId: z.string().uuid(),
      data: z.object({
        theme: z.string().optional(),
        morningFocus: z.string().optional(),
        afternoonFocus: z.string().optional(),
        eveningFocus: z.string().optional(),
        morningFocusFormal: z.string().optional(),
        afternoonFocusFormal: z.string().optional(),
        eveningFocusFormal: z.string().optional(),
      }),
    })
  )
  .mutation(async ({ ctx, input }) => {
    // Verify day belongs to user's org
    const day = await ctx.prisma.programmeDay.findFirst({
      where: {
        id: input.dayId,
        programme: {
          tenantId: ctx.orgId,
        },
      },
    })

    if (!day) {
      throw new Error('Programme day not found or unauthorized')
    }

    return await ctx.prisma.programmeDay.update({
      where: { id: input.dayId },
      data: input.data,
    })
  }),
```

**Update updateSession input schema:**

```typescript
data: z.object({
  // ... existing fields

  // NEW: Formal mode fields
  titleFormal: z.string().optional(),
  descriptionFormal: z.string().optional(),
  preparationNotesFormal: z.string().optional(),
}),
```

---

#### UPDATE /app/src/inngest/functions/generate-project.ts

- **IMPLEMENT**: Save formal fields when creating project
- **PATTERN**: Extend existing save-project step (lines 58-90)
- **IMPORTS**: None (updating existing)
- **GOTCHA**: Concept object now has formal fields
- **VALIDATE**: Generated projects have both versions

**Update project creation data:**

```typescript
const project = await step.run('save-project', async () => {
  return await prisma.project.create({
    data: {
      // ... existing fields

      // Working mode fields
      targetGroupDescription: concept.targetGroupDescription,
      inclusionPlanOverview: concept.inclusionPlanOverview,
      partnerProfile: concept.partnerProfile,
      sustainabilityNarrative: concept.sustainabilityNarrative,
      impactNarrative: concept.impactNarrative,

      // NEW: Formal mode fields
      targetGroupDescriptionFormal: concept.targetGroupDescriptionFormal,
      inclusionPlanOverviewFormal: concept.inclusionPlanOverviewFormal,
      partnerProfileFormal: concept.partnerProfileFormal,
      sustainabilityNarrativeFormal: concept.sustainabilityNarrativeFormal,
      impactNarrativeFormal: concept.impactNarrativeFormal,
    },
  })
})
```

---

#### UPDATE /app/src/server/routers/programmes.ts (programme creation)

- **IMPLEMENT**: Save formal fields when creating programme from AI output
- **PATTERN**: Extend existing programme creation (lines 58-114)
- **IMPORTS**: None (updating existing)
- **GOTCHA**: dailyStructure and sessions now have formal fields
- **VALIDATE**: Generated programmes have both versions

**Update day/session creation:**

```typescript
days: {
  create: dailyStructure.map((day) => {
    const daySessions = allSessions.find(s => s.dayNumber === day.day_number)?.sessions || []

    return {
      dayNumber: day.day_number,
      theme: day.theme,
      // Working mode
      morningFocus: day.morning_focus,
      afternoonFocus: day.afternoon_focus,
      eveningFocus: day.evening_focus,
      // NEW: Formal mode
      morningFocusFormal: day.morning_focus_formal,
      afternoonFocusFormal: day.afternoon_focus_formal,
      eveningFocusFormal: day.evening_focus_formal,

      sessions: {
        create: daySessions.map((session, sessionIndex) => ({
          // Working mode
          title: session.title,
          description: session.description,
          preparationNotes: session.preparation_notes,
          // NEW: Formal mode
          titleFormal: session.title_formal,
          descriptionFormal: session.description_formal,
          preparationNotesFormal: session.preparation_notes_formal,
          // ... other fields
        })),
      },
    }
  }),
}
```

---

### Phase 5: Frontend Integration

#### CREATE /app/src/components/layout/ContentModeToggle.tsx

- **IMPLEMENT**: Toggle button component for header
- **PATTERN**: Button + Badge combination from project page patterns
- **IMPORTS**:
  ```typescript
  'use client'
  import { useContentModeStore } from '@/lib/stores/contentModeStore'
  import { Button } from '@/components/ui/button'
  import { Badge } from '@/components/ui/badge'
  import { FileText, ScrollText } from 'lucide-react'
  ```
- **GOTCHA**: Must be client component for Zustand
- **VALIDATE**: Component renders and toggles mode

**Implementation:**

```typescript
'use client'

import { useContentModeStore } from '@/lib/stores/contentModeStore'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import { FileText, ScrollText } from 'lucide-react'

export function ContentModeToggle() {
  const { mode, toggleMode, isWorking } = useContentModeStore()

  return (
    <div className="flex items-center gap-3">
      <Badge variant={isWorking ? 'default' : 'secondary'} className="text-xs">
        {isWorking ? (
          <>
            <FileText className="mr-1 h-3 w-3" />
            Working Mode
          </>
        ) : (
          <>
            <ScrollText className="mr-1 h-3 w-3" />
            Formal Mode
          </>
        )}
      </Badge>

      <Button
        variant="outline"
        size="sm"
        onClick={toggleMode}
        className="text-xs"
        title={`Switch to ${isWorking ? 'Formal' : 'Working'} Mode`}
      >
        Switch to {isWorking ? 'Formal' : 'Working'}
      </Button>
    </div>
  )
}
```

---

#### CREATE /app/src/components/ui/ContentModeBadge.tsx

- **IMPLEMENT**: Mode indicator badge for field sections
- **PATTERN**: Badge usage from programme page (lines 241-248)
- **IMPORTS**:
  ```typescript
  'use client'
  import { useContentModeStore } from '@/lib/stores/contentModeStore'
  import { Badge } from '@/components/ui/badge'
  import { hasFormalVersion } from '@/lib/hooks/useContentField'
  import { AlertCircle } from 'lucide-react'
  ```
- **GOTCHA**: Show warning if formal version missing in formal mode
- **VALIDATE**: Badge displays correct mode and warnings

**Implementation:**

```typescript
'use client'

import { useContentModeStore } from '@/lib/stores/contentModeStore'
import { Badge } from '@/components/ui/badge'
import { hasFormalVersion } from '@/lib/hooks/useContentField'
import { AlertCircle } from 'lucide-react'

interface ContentModeBadgeProps {
  formalValue?: string | null
  inline?: boolean
  className?: string
}

export function ContentModeBadge({
  formalValue,
  inline = false,
  className = ''
}: ContentModeBadgeProps) {
  const { isFormal } = useContentModeStore()
  const hasFormal = hasFormalVersion(formalValue)

  if (isFormal && !hasFormal) {
    return (
      <Badge variant="outline" className={`text-xs text-amber-600 ${className}`}>
        <AlertCircle className="mr-1 h-3 w-3" />
        No formal version (showing working)
      </Badge>
    )
  }

  return null
}
```

---

#### UPDATE /app/src/components/layout/Header.tsx

- **IMPLEMENT**: Add ContentModeToggle to header right section
- **PATTERN**: Existing header structure (full file)
- **IMPORTS**: `import { ContentModeToggle } from './ContentModeToggle'`
- **GOTCHA**: Maintain existing flex layout
- **VALIDATE**: npm run build succeeds, header displays toggle

**Change:**

```typescript
// Add import at top
import { ContentModeToggle } from './ContentModeToggle'

// Update right section (around line 9-11):
<div className="flex items-center gap-4">
  <ContentModeToggle />  {/* NEW */}
  <span className="text-sm text-zinc-500">Auth Disabled - Development Mode</span>
</div>
```

---

#### UPDATE /app/src/app/(dashboard)/projects/[id]/page.tsx

- **IMPLEMENT**: Apply content mode display to 5 project fields
- **PATTERN**: Existing field display sections (lines 293-435)
- **IMPORTS**:
  ```typescript
  'use client'
  import { useContentField } from '@/lib/hooks/useContentField'
  import { ContentModeBadge } from '@/components/ui/ContentModeBadge'
  ```
- **GOTCHA**: Component already has 'use client', safe to use hooks
- **VALIDATE**: Fields switch when toggle clicked

**Apply to each affected field section:**

```typescript
// Add at component top (after existing hooks):
const displayField = useContentField

// Update Target Group section (around line 345):
<Card className="mb-6">
  <CardHeader>
    <div className="flex items-center justify-between">
      <CardTitle>Target Group</CardTitle>
      <ContentModeBadge formalValue={project.targetGroupDescriptionFormal} />
    </div>
  </CardHeader>
  <CardContent>
    <p className="whitespace-pre-wrap">
      {displayField(
        project.targetGroupDescription,
        project.targetGroupDescriptionFormal
      )}
    </p>
  </CardContent>
</Card>

// Repeat pattern for:
// - Inclusion Plan (inclusionPlanOverview/inclusionPlanOverviewFormal)
// - Partner Profile (partnerProfile/partnerProfileFormal)
// - Sustainability (sustainabilityNarrative/sustainabilityNarrativeFormal)
// - Impact (impactNarrative/impactNarrativeFormal)
```

**Add formalize button (optional):**

```typescript
// In header action buttons section:
const formalizeMutation = trpc.projects.formalizeProject.useMutation({
  onSuccess: () => {
    utils.projects.getById.invalidate({ id })
    toast.success('Formal versions generated')
  },
  onError: (error) => {
    toast.error(`Failed to formalize: ${error.message}`)
  },
})

// Button:
<Button
  variant="outline"
  size="sm"
  onClick={() => formalizeMutation.mutate({ id })}
  disabled={formalizeMutation.isPending}
>
  {formalizeMutation.isPending ? (
    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
  ) : (
    <ScrollText className="mr-2 h-4 w-4" />
  )}
  Generate Formal Versions
</Button>
```

---

#### UPDATE /app/src/app/(dashboard)/projects/[id]/programme/page.tsx

- **IMPLEMENT**: Apply content mode display to programme days and sessions
- **PATTERN**: Existing display patterns (lines 179-330)
- **IMPORTS**: Same as project page
- **GOTCHA**: 6 fields to update (3 day focus + 3 session fields)
- **VALIDATE**: All programme fields switch with toggle

**Apply to day focus fields:**

```typescript
// In ProgrammeDay card (around line 199):
<CardContent>
  <div className="grid gap-4 md:grid-cols-3">
    {day.morningFocus && (
      <div>
        <p className="text-sm font-medium text-zinc-500">Morning Focus</p>
        <ContentModeBadge formalValue={day.morningFocusFormal} inline />
        <p className="mt-1 text-sm">
          {displayField(day.morningFocus, day.morningFocusFormal)}
        </p>
      </div>
    )}
    {/* Repeat for afternoonFocus and eveningFocus */}
  </div>
</CardContent>
```

**Apply to session fields:**

```typescript
// Session title (around line 251):
<CardTitle>
  {displayField(session.title, session.titleFormal)}
  <ContentModeBadge formalValue={session.titleFormal} inline />
</CardTitle>

// Session description (around line 263):
{session.description && (
  <p className="text-sm text-zinc-700">
    {displayField(session.description, session.descriptionFormal)}
  </p>
)}

// Preparation notes (around line 318):
{session.preparationNotes && (
  <div className="mt-4 rounded-lg bg-blue-50 p-3 text-sm">
    <p className="font-medium text-blue-900">Facilitator Notes</p>
    <p className="mt-1 text-blue-800">
      {displayField(session.preparationNotes, session.preparationNotesFormal)}
    </p>
  </div>
)}
```

---

## TESTING STRATEGY

### Unit Tests (Optional - No existing test framework)

If implementing tests, use Jest + React Testing Library:

```typescript
// contentModeStore.test.ts
describe('useContentModeStore', () => {
  it('defaults to working mode', () => {
    const { mode } = useContentModeStore.getState()
    expect(mode).toBe('working')
  })

  it('toggles between modes', () => {
    const { toggleMode, mode } = useContentModeStore.getState()
    toggleMode()
    expect(useContentModeStore.getState().mode).toBe('formal')
  })

  it('persists to localStorage', () => {
    // Test localStorage persistence
  })
})

// useContentField.test.ts
describe('useContentField', () => {
  it('returns working value when in working mode', () => {
    // ...
  })

  it('returns formal value when in formal mode', () => {
    // ...
  })

  it('falls back to working when formal missing', () => {
    // ...
  })
})
```

### Integration Tests

**Manual Testing Checklist:**

1. **Toggle Functionality**
   - [ ] Toggle appears in header
   - [ ] Clicking toggle switches mode
   - [ ] Badge updates to show current mode
   - [ ] All 11 fields update across pages

2. **Persistence**
   - [ ] Refresh page - mode persists
   - [ ] Close/reopen browser - mode persists
   - [ ] Open in new tab - mode syncs

3. **Fallback Behavior**
   - [ ] Create new project without formal versions
   - [ ] Switch to formal mode
   - [ ] Verify working text shows with warning badge
   - [ ] No errors in console

4. **AI Generation**
   - [ ] Generate new project
   - [ ] Verify both working and formal fields populated
   - [ ] Check formal language quality (Erasmus+ terminology)
   - [ ] Generate programme
   - [ ] Verify all 6 programme fields have both versions

5. **Formalization**
   - [ ] Use "Generate Formal Versions" button
   - [ ] Verify all empty formal fields populated
   - [ ] Check quality and consistency

6. **Edge Cases**
   - [ ] Very long text fields (>1000 chars)
   - [ ] Empty working fields
   - [ ] Special characters in text
   - [ ] Multiple projects in quick succession

### Performance Testing

- Measure page load time with 20+ projects
- Test toggle responsiveness (should be instant)
- Check AI formalization latency (acceptable <10s)
- Monitor localStorage size growth

---

## VALIDATION COMMANDS

Execute every command to ensure zero regressions and 100% feature correctness.

### Level 1: Import Validation (CRITICAL)

```bash
cd /worktrees/openhorizon.cc/issue-1/app
npm run build
```

**Expected:** Build completes successfully, no import errors

**Why:** Catches incorrect imports (Zustand, new chains) immediately

### Level 2: Database Validation

```bash
cd /worktrees/openhorizon.cc/issue-1/app
npx prisma validate
npx prisma generate
```

**Expected:** Schema valid, client generated successfully

### Level 3: TypeScript Type Checking

```bash
cd /worktrees/openhorizon.cc/issue-1/app
npx tsc --noEmit
```

**Expected:** No type errors

### Level 4: Linting

```bash
cd /worktrees/openhorizon.cc/issue-1/app
npm run lint
```

**Expected:** No linting errors

### Level 5: Development Server

```bash
cd /worktrees/openhorizon.cc/issue-1/app
npm run dev
```

**Expected:** Server starts without errors on port 3000

### Level 6: Manual Validation

**Test Flow:**
1. Navigate to http://localhost:3000
2. Go to project detail page
3. Verify toggle in header
4. Click toggle - verify fields change
5. Refresh page - verify mode persisted
6. Generate new project - verify both versions
7. Generate programme - verify both versions
8. Check all 11 fields across pages

---

## ACCEPTANCE CRITERIA

- [ ] Toggle visible in header at all times
- [ ] Toggle switches between Working and Formal modes
- [ ] Mode selection persists across browser sessions (localStorage)
- [ ] All 11 fields display correct version based on mode:
  - [ ] 5 project fields
  - [ ] 3 programme day fields
  - [ ] 3 programme session fields
- [ ] New projects generate with both versions
- [ ] New programmes generate with both versions
- [ ] "Generate Formal Versions" button works for existing projects
- [ ] Graceful fallback when formal version missing (show working + warning)
- [ ] No breaking changes to existing functionality
- [ ] All validation commands pass
- [ ] No console errors or warnings
- [ ] Performance acceptable (toggle instant, generation <10s)

---

## COMPLETION CHECKLIST

- [ ] Database migration completed successfully
- [ ] Zustand store created and working
- [ ] Content formalization chain implemented
- [ ] All AI generation prompts updated
- [ ] Backend mutations added and tested
- [ ] Header toggle integrated
- [ ] Project page updated (5 fields)
- [ ] Programme page updated (6 fields)
- [ ] Toggle functionality tested
- [ ] Persistence tested
- [ ] AI generation tested
- [ ] Formalization tested
- [ ] All validation commands pass
- [ ] Manual testing checklist complete
- [ ] No regressions in existing features

---

## NOTES

### Design Decisions

**Why dual storage over single storage with AI translation?**
- Predictable: Always know what formal version will show
- Editable: Users can customize formal language
- Fast: No API calls for display
- Reliable: Not dependent on AI availability

**Why working mode as default?**
- More authentic for planning
- Less intimidating for coordinators
- Matches actual workflow (plan → formalize)
- Formal mode is for applications, not daily use

**Why global toggle vs field-level?**
- Simpler UX - one control for entire page
- Consistent experience across sections
- Matches mental model (view as coordinator vs view as evaluator)
- Easier implementation

### Trade-offs

**Pros:**
- Clear separation of working and formal language
- AI-powered formalization saves time
- Flexibility to edit either version
- Authentic planning workflow

**Cons:**
- Doubles storage for affected fields (~40% increase in text data)
- Potential for working/formal divergence over time
- AI costs for formalization (acceptable for value)
- More complex data model

### Future Enhancements

1. **Comparison View**: Side-by-side working vs formal
2. **Version History**: Track changes to formal versions
3. **Template Library**: Pre-built formal phrases for common scenarios
4. **Export Control**: Choose mode when exporting PDF/Word
5. **Field-Level Lock**: Lock specific fields to one mode
6. **AI Suggestions**: Highlight differences and suggest improvements
7. **Batch Formalization**: Formalize multiple projects at once
8. **Custom Formalization Styles**: Organization-specific formal language patterns
